This section presents experimental results for our compilation strategy.  We
compare the execution speed of our new compiled code against hand-written
implementations in C of the same programs. We also compare the results against
interpreted execution. Although interpreted execution uses a similar
translation, it helps us understand the limitations of the compilation scheme by
removing the interpretation overhead.

For our experimental setup, we used a computer with a 24 (4x6) Core AMD
Opteron(tm) Processor 8425 HE $@$ 800 MHz with 64 GBytes of RAM memory and runs
the Linux kernel 3.15.10-201.fc20.x86\_64. The C++ compiler used is GCC 4.8.3
(g++) with the flags: \texttt{-O3 -std=c+0x
   -march=x86-64}.  We run all experiments 3 times and averaged the
execution time.

We have implemented 5 different LM programs and their corresponding
C versions. The programs are the following:

\begin{itemize}
\item Shortest Path (SP): a slightly modified version of the program
                                  presented in
                                  Fig.~\ref{fig:shortest_path_program}, where
                                  the shortest distance is computed from all
                                  nodes to all nodes.

\item MiniMax: the AI algorithm for selecting the best player move in a game of
Tic-Tac-Toe. The initial board was augmented in order to provide a longer
running benchmark.

\item N-Queens: the classic puzzle for placing queens on a chess board so that
no two queens threaten each other.

\item Belief Propagation: a machine learning algorithm to denoise images.

\item Heat Transfer: an asynchronous program that performs transfer of heat
between nodes.
\end{itemize}

Table~\ref{fig:table_results} presents the results comparing compiled code and
interpreted code against C programs. Comparisons to other systems are shown
under the \textbf{Other} column. Note that the program sizes are in ascending
order.

\begin{table}[ht]
\begin{center}
    \begin{tabular}{ | l | c | c | c | c |}
    \hline
    \textbf{Program} & \textbf{Size} & \textbf{Compiled} & \textbf{Interpreted}
    & \textbf{Other} \\ \hline \hline
    \multirow{3}{*}{Shortest Path} & US Airports & 4.7 & 9.7 & 13.3 (python) \\
    & OCLinks & 6.3 & 13.5 & 11.2 (python) \\
    & Powergrid & 4.2 & 13.5 & 10.6 (python) \\ \hline \hline
    \multirow{3}{*}{N-Queens} & 11 & 3.2 & 4.7 & 20.8 (python) \\
    & 12 & 4.6 & 6 & 24.1 (python) \\
    & 13 & 6.2 & 7.6 & 26.0 (python) \\
    & 14 & 7.3 & 8.8 & 28.0 (python) \\ \hline \hline
    \multirow{4}{*}{Belief Propagation} & 50 & 1.3 & 1.4 & \\
    & 200 & 1.3 & 1.4 & \\ 
    & 300 & 1.2 & 1.4 & \\
    & 400 & 1.3 & 1.4 & \\ \hline \hline
    \multirow{2}{*}{Heat Transfer} & 80 & 6.9 & 10.6 & - \\
    & 120 & & 11.6 & - \\ \hline \hline
    MiniMax & - & 4.0 & 6.2 & 9.3 \\ \hline \hline
    \end{tabular}
\end{center}
\caption{Experimental results comparing different programs against hand-written
   versions in C. \textbf{Lower is better.} The numbers in the table are computed by dividing the
   execution time of the system of that column by the execution time of a
   similar hand-written version in C.}
\label{fig:table_results}
\end{table}

The Shortest Path program shows good improvements from the interpreted run
time, since the run time is reduced by around 50\%. This indicates that the
program performs repeated comparisons between integer numbers, which tend to be
slower in interpreted code. The good performance results come from the fact that
the program has only two rules where the shortest distance fact is updated or
kept. The distance facts are also indexed by the source node, which helps the
code filter through the candidate distances more quickly.

N-Queens presents some scalability issues for our compilation scheme due to the
exponential increase of facts as the problem size increases,
however, the same behavior can also be observed in the Python program. The
interpreted version is already reasonably fast (slowdown is less than 10). The
compiled version reduces the interpreted run time by 20\% which indicates that
not many operations are performed in the rules and most of the run time is spent
manipulating the database.

The Belief Propagation program is made of many expensive floating point
calculations. The interpreted version used external functions written in C to
implement those operations because otherwise it would be too slow. Therefore,
and since the rules tend to manipulate a small number of facts, the interpreted
and compiled versions perform about the same. This program has also the best
results which proves that the program spends a huge amount of time performing
floating point calculations.

The Heat Transfer program also performs floating operations but in a much
smaller scale than Belief Propagation. This is noticiable from the results since
the slowdown is much larger than Belief Propagation. The program also needs to
compute many sum aggregates, which makes the interpreted version incur in some
overhead due to the integer operations.

While all the other programs perform computations on a pre-defined set of nodes,
the MiniMax program creates the nodes of the graph dynamically.
Creating new nodes, requires creating new databases which tends to take a
considerable fraction of the run time. This is attested by the small reduction
of run time from the compiled version to the interpreted version.

It should be noted that in these programs there is a slightly parallelization
overhead, since the supporting runtime allows programs to be parallelized.
This means that most programs shown in Table~\ref{fig:table_results} easily beat C
when using 2 to 6 threads.


\iffalse
interpreted
sp powergrid: 13007
sp oclinks: 5704
sp airports: 1199
minimax: 45207
queens 11: 1124
queens 12: 7925
queens 13: 60221
queens 14: 436541
bp 50: 3826
bp 200: 74407
bp 300: 198903
bp 400: 260063
ht 80: 77277
ht 120: 382982

C
sp powergrid: 966
sp oclinks: 422
sp airports: 115
minimax:  7267
queens 11: 238
queens 12: 1320
queens 13: 7837
queens 14: 49258
bp 50: 2822
bp 200: 51506
bp 300: 141000
bp 400: 180000
ht 80: 7291
ht 120: 32916

python
sp powergrid: 10221
sp oclinks: 4726
sp airports: 1525
queens 11: 4964
queens 12: 31792
queens 13: 204000
queens 14: 1379000
minimax: 67486

compiled
sp powergrid: 4075
sp oclinks: 2667
sp airports: 547
minimax: 29616
queens 11: 772
queens 12: 6113
queens 13: 48756
queens 14: 360710
bp 50: 3508
bp 200: 64237
bp 300: 172000
bp 400: 229012
ht 80: 50486
ht 120: 254359
\fi
